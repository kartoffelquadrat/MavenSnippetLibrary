{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Maven Snippet Library Maven is a powerful build tool. Yet the many configuration options offered are often overwhelming to newcomers. Even setting up a simple Hello, World! project that just works can be at first a little tedious. About this Page This web page hosts a step by step guide, that takes you from a minimal valid configuration to advanced features, such as enforced checkstyle and documentation rules to ensure a minimum of code quality. All the snippets on this page are taken from my own projects, they have been tested and proven over the past years. Contributions Feel free to report errors or suggestions via merge requests to https://github.com/m5c/MavenSnippetLibrary . Note that you need mkdocs to build the webpage. The site is generated from markdowns, so make sure to edit those, not the HTML files. Most of all have lots of fun and happy coding, Max","title":"Welcome"},{"location":"#maven-snippet-library","text":"Maven is a powerful build tool. Yet the many configuration options offered are often overwhelming to newcomers. Even setting up a simple Hello, World! project that just works can be at first a little tedious.","title":"Maven Snippet Library"},{"location":"#about-this-page","text":"This web page hosts a step by step guide, that takes you from a minimal valid configuration to advanced features, such as enforced checkstyle and documentation rules to ensure a minimum of code quality. All the snippets on this page are taken from my own projects, they have been tested and proven over the past years.","title":"About this Page"},{"location":"#contributions","text":"Feel free to report errors or suggestions via merge requests to https://github.com/m5c/MavenSnippetLibrary . Note that you need mkdocs to build the webpage. The site is generated from markdowns, so make sure to edit those, not the HTML files. Most of all have lots of fun and happy coding, Max","title":"Contributions"},{"location":"artifactbuild/","text":"Artifact Build Often you want to run a software without first cloning or building the sources. In fact, almost any time you download a software from the internet you receive a precompiled release rather than source code. It is actually not so trivial to obtain such a standalone executable that comes a single file, with all its dependencies included. Maven comes with powerful mechanisms to build your project to a wholesome Java Archive (JAR) file. In this case, all dependencies are included - however the customer still needs a Java Runtime Environment (JRE). Note: It is also possible to include the JRE dependencies themselves. However, for simplicity this is not covered in this guide. Additional info on true platform specific standalones e.g. Mac can be found here . Creating a JAR with all dependencies Once more this is a goal best achieved by help of targeted plugins. Similar to the Direct Run module we needed to provide a pointer to the desired launcher class, we need to tell the jar-creating plugin about the entry point to our code. Below are three snippets for Vanilla , Spring Boot and JavaFX projects. There are many more plugins for further frameworks, but this selection should give you a good illustration of the procedure. Add the desired plugin to your pom.xml Then compile / build a self contained jar with: mvn clean package Finally run the produced jar: java -jar target/whatever.jar Vanilla / No Frameworks Spring Boot Java FX <plugin> <artifactId> maven-assembly-plugin </artifactId> <executions> <execution> <phase> package </phase> <goals> <goal> single </goal> </goals> </execution> </executions> <configuration> <archive> <manifest> <addClasspath> true </addClasspath> <mainClass> eu.kartoffelquadrat.zoo.Launcher </mainClass> </manifest> </archive> <descriptorRefs> <descriptorRef> jar-with-dependencies </descriptorRef> </descriptorRefs> <finalName> AcquireBanker </finalName> <appendAssemblyId> false </appendAssemblyId> </configuration> </plugin> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> <configuration> <fork> true </fork> <mainClass> eu.kartoffelquadrat.zoo.RestLauncher </mainClass> </configuration> <executions> <execution> <goals> <goal> repackage </goal> </goals> </execution> </executions> </plugin> <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.4.0 </version> <executions> <execution> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <transformers> <transformer implementation= \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" > <mainClass> eu.kartoffelquadrat.javafxhelloworld.SuperLauncher </mainClass> </transformer> </transformers> </configuration> </execution> </executions> </plugin>","title":"Artifact Build"},{"location":"artifactbuild/#artifact-build","text":"Often you want to run a software without first cloning or building the sources. In fact, almost any time you download a software from the internet you receive a precompiled release rather than source code. It is actually not so trivial to obtain such a standalone executable that comes a single file, with all its dependencies included. Maven comes with powerful mechanisms to build your project to a wholesome Java Archive (JAR) file. In this case, all dependencies are included - however the customer still needs a Java Runtime Environment (JRE). Note: It is also possible to include the JRE dependencies themselves. However, for simplicity this is not covered in this guide. Additional info on true platform specific standalones e.g. Mac can be found here .","title":"Artifact Build"},{"location":"artifactbuild/#creating-a-jar-with-all-dependencies","text":"Once more this is a goal best achieved by help of targeted plugins. Similar to the Direct Run module we needed to provide a pointer to the desired launcher class, we need to tell the jar-creating plugin about the entry point to our code. Below are three snippets for Vanilla , Spring Boot and JavaFX projects. There are many more plugins for further frameworks, but this selection should give you a good illustration of the procedure. Add the desired plugin to your pom.xml Then compile / build a self contained jar with: mvn clean package Finally run the produced jar: java -jar target/whatever.jar Vanilla / No Frameworks Spring Boot Java FX <plugin> <artifactId> maven-assembly-plugin </artifactId> <executions> <execution> <phase> package </phase> <goals> <goal> single </goal> </goals> </execution> </executions> <configuration> <archive> <manifest> <addClasspath> true </addClasspath> <mainClass> eu.kartoffelquadrat.zoo.Launcher </mainClass> </manifest> </archive> <descriptorRefs> <descriptorRef> jar-with-dependencies </descriptorRef> </descriptorRefs> <finalName> AcquireBanker </finalName> <appendAssemblyId> false </appendAssemblyId> </configuration> </plugin> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> <configuration> <fork> true </fork> <mainClass> eu.kartoffelquadrat.zoo.RestLauncher </mainClass> </configuration> <executions> <execution> <goals> <goal> repackage </goal> </goals> </execution> </executions> </plugin> <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.4.0 </version> <executions> <execution> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <transformers> <transformer implementation= \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" > <mainClass> eu.kartoffelquadrat.javafxhelloworld.SuperLauncher </mainClass> </transformer> </transformers> </configuration> </execution> </executions> </plugin>","title":"Creating a JAR with all dependencies"},{"location":"bestpractices/","text":"Build Best Practices Just because a program seemingly works, that does not mean it is free of errors or well written code. Most good programmers agree that code gains significantly in quality, if: Style-Checked Documented Tested Below I show you which plugins you can integrate into your project to enforce this minimal quality on your code. Note: Very likely your program will at first no longer run once you enable all below plugins. It can be tempting to just remove the plugins again as a \" quick fix \". However, keep in mind that you then only turn off the flashing warning lights, not the actual quality issues with your code. Checkstyle First of all you will need a checkstyle configuration file. I recommend the one by google . The checkstyle file is simply a restrictive linter configuration that inherently knows about all naming and indentation conventions for java code. Download the google_checks.xml file and place it in your project's root directory, right next to the pom.xml . Next you need to enable the Maven Checkstyle Plugin in your pom.xml . Paste the below snippet somewhere between your pom.xml s <plugins>...</plugins> tags. <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-checkstyle-plugin </artifactId> <version> 3.2.0 </version> <configuration> <configLocation> google_checks.xml </configLocation> <consoleOutput> true </consoleOutput> <violationSeverity> warning </violationSeverity> <failOnViolation> true </failOnViolation> <failsOnError> true </failsOnError> <linkXRef> false </linkXRef> </configuration> <executions> <execution> <id> validate </id> <phase> validate </phase> <goals> <goal> check </goal> </goals> </execution> </executions> </plugin> Effect From now on, maven will invoke the checkstyle linter every single time you attempt to build or run your code. Note that your program will not start unless your code complies to all checkstyle rules. This even includes formatting. While this sounds tedious at first, this plugin is a guaranteed time and trouble saver - it also prevents anyone else from adding any poorly formatted or weirdly named code. JavaDoc The JavaDoc plugin does no require an extra configuration file. Simply enable the JavaDoc Plugin in your pom.xml . To do so, paste the below snippet somewhere between your pom.xml s <plugins>...</plugins> tags. <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-javadoc-plugin </artifactId> <version> 3.4.0 </version> <configuration> <source> 8 </source> <javadocExecutable> ${java.home}/bin/javadoc </javadocExecutable> <reportOutputDirectory> ${project.reporting.outputDirectory}/docs </reportOutputDirectory> <destDir> docs </destDir> </configuration> <executions> <execution> <id> attach-javadocs </id> <goals> <goal> jar </goal> </goals> <configuration> <failOnWarnings> true </failOnWarnings> </configuration> </execution> </executions> </plugin> Effect This plugin does two things: It first ensures all your methods are documented. That means unless a method @overrides a base class or interface, it must carry a javadoc description, explaining the inputs and outputs of your signature, including mention of potential exceptions. Here is a little example: /** * Little demo method to count a given amount of sheep. * @param sheep as the amount of sheep to count. * @returns boolean indicating if any black sheep were encountered. * @throws IOException in case a sheep jumped a fence. */ public static boolean count ( int sheep ) throws IOException { [ ... ] } If and only if all methods are fully documented, the build process continues and the plug generates a human readable HTML Java API documentation to the docs folder. Note that you can use this output as-is, e.g. for your GitHub pages project documentation, so everyone working with your codebase has a convenient access to user navigable documentation. Also, since this documentation is created on every build or run, it automatically stays fully up to date. Note: The above plugin is set to the strictest possible configuration. Even warnings are interpreted as a direct compile failure. ( failOnWarnings : true ). To good side is that you can be sure your codebase never has a single undocumented method parameter. Unit Tests Unit tests should be a central part of project. It is too easy to introduce a little bug to an existing feature while working on a seemingly unrelated part of the codebase. This is why you should run your Unit tests as frequently as possible. The Surfire plugin allows you just to do that! It enforces all Unit tests must run, before you can build or run your software. Unlike the previous plugins, this one is enabled via a plugin snippet in combination with a test scoped dependency . Paste the below snippets somewhere between your pom.xml s respective <dependencies>...</dependencies> and <plugins>...</plugins> tags: Dependency snippet <dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> 4.10 </version> <scope> test </scope> </dependency> Plugin snippet <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.22.2 </version> </plugin> Effect Once added, you can be assured all tests have passed whenever you see you program run. A very assuring feeling, especially while working on missing features under the effects of an approaching deadline. But don't forget to actually code good unit tests! Those belong into the src/test/java directory. Some developers tend to create a class with *Test``` suffix for every class they test, so they see a direct matching. In the end it does not really matter, as long as you reach a good coverage and check for the non-trivial scenarios. Here is a little stub of what a simple test java class may look like: package ca.mcgill.countingsheep.model ; import org.junit.Test ; public class SheepTest { @Test public void testSheep () { Sheep keksli = new Sheep ( \"Keksli\" ); assert keksli . getName (). equals ( \"Keksli\" ); } }","title":"Best Practices"},{"location":"bestpractices/#build-best-practices","text":"Just because a program seemingly works, that does not mean it is free of errors or well written code. Most good programmers agree that code gains significantly in quality, if: Style-Checked Documented Tested Below I show you which plugins you can integrate into your project to enforce this minimal quality on your code. Note: Very likely your program will at first no longer run once you enable all below plugins. It can be tempting to just remove the plugins again as a \" quick fix \". However, keep in mind that you then only turn off the flashing warning lights, not the actual quality issues with your code.","title":"Build Best Practices"},{"location":"bestpractices/#checkstyle","text":"First of all you will need a checkstyle configuration file. I recommend the one by google . The checkstyle file is simply a restrictive linter configuration that inherently knows about all naming and indentation conventions for java code. Download the google_checks.xml file and place it in your project's root directory, right next to the pom.xml . Next you need to enable the Maven Checkstyle Plugin in your pom.xml . Paste the below snippet somewhere between your pom.xml s <plugins>...</plugins> tags. <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-checkstyle-plugin </artifactId> <version> 3.2.0 </version> <configuration> <configLocation> google_checks.xml </configLocation> <consoleOutput> true </consoleOutput> <violationSeverity> warning </violationSeverity> <failOnViolation> true </failOnViolation> <failsOnError> true </failsOnError> <linkXRef> false </linkXRef> </configuration> <executions> <execution> <id> validate </id> <phase> validate </phase> <goals> <goal> check </goal> </goals> </execution> </executions> </plugin>","title":"Checkstyle"},{"location":"bestpractices/#effect","text":"From now on, maven will invoke the checkstyle linter every single time you attempt to build or run your code. Note that your program will not start unless your code complies to all checkstyle rules. This even includes formatting. While this sounds tedious at first, this plugin is a guaranteed time and trouble saver - it also prevents anyone else from adding any poorly formatted or weirdly named code.","title":"Effect"},{"location":"bestpractices/#javadoc","text":"The JavaDoc plugin does no require an extra configuration file. Simply enable the JavaDoc Plugin in your pom.xml . To do so, paste the below snippet somewhere between your pom.xml s <plugins>...</plugins> tags. <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-javadoc-plugin </artifactId> <version> 3.4.0 </version> <configuration> <source> 8 </source> <javadocExecutable> ${java.home}/bin/javadoc </javadocExecutable> <reportOutputDirectory> ${project.reporting.outputDirectory}/docs </reportOutputDirectory> <destDir> docs </destDir> </configuration> <executions> <execution> <id> attach-javadocs </id> <goals> <goal> jar </goal> </goals> <configuration> <failOnWarnings> true </failOnWarnings> </configuration> </execution> </executions> </plugin>","title":"JavaDoc"},{"location":"bestpractices/#effect_1","text":"This plugin does two things: It first ensures all your methods are documented. That means unless a method @overrides a base class or interface, it must carry a javadoc description, explaining the inputs and outputs of your signature, including mention of potential exceptions. Here is a little example: /** * Little demo method to count a given amount of sheep. * @param sheep as the amount of sheep to count. * @returns boolean indicating if any black sheep were encountered. * @throws IOException in case a sheep jumped a fence. */ public static boolean count ( int sheep ) throws IOException { [ ... ] } If and only if all methods are fully documented, the build process continues and the plug generates a human readable HTML Java API documentation to the docs folder. Note that you can use this output as-is, e.g. for your GitHub pages project documentation, so everyone working with your codebase has a convenient access to user navigable documentation. Also, since this documentation is created on every build or run, it automatically stays fully up to date. Note: The above plugin is set to the strictest possible configuration. Even warnings are interpreted as a direct compile failure. ( failOnWarnings : true ). To good side is that you can be sure your codebase never has a single undocumented method parameter.","title":"Effect"},{"location":"bestpractices/#unit-tests","text":"Unit tests should be a central part of project. It is too easy to introduce a little bug to an existing feature while working on a seemingly unrelated part of the codebase. This is why you should run your Unit tests as frequently as possible. The Surfire plugin allows you just to do that! It enforces all Unit tests must run, before you can build or run your software. Unlike the previous plugins, this one is enabled via a plugin snippet in combination with a test scoped dependency . Paste the below snippets somewhere between your pom.xml s respective <dependencies>...</dependencies> and <plugins>...</plugins> tags:","title":"Unit Tests"},{"location":"bestpractices/#dependency-snippet","text":"<dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> 4.10 </version> <scope> test </scope> </dependency>","title":"Dependency snippet"},{"location":"bestpractices/#plugin-snippet","text":"<plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.22.2 </version> </plugin>","title":"Plugin snippet"},{"location":"bestpractices/#effect_2","text":"Once added, you can be assured all tests have passed whenever you see you program run. A very assuring feeling, especially while working on missing features under the effects of an approaching deadline. But don't forget to actually code good unit tests! Those belong into the src/test/java directory. Some developers tend to create a class with *Test``` suffix for every class they test, so they see a direct matching. In the end it does not really matter, as long as you reach a good coverage and check for the non-trivial scenarios. Here is a little stub of what a simple test java class may look like: package ca.mcgill.countingsheep.model ; import org.junit.Test ; public class SheepTest { @Test public void testSheep () { Sheep keksli = new Sheep ( \"Keksli\" ); assert keksli . getName (). equals ( \"Keksli\" ); } }","title":"Effect"},{"location":"dependencies/","text":"Compile Time Dependencies Most programmers at first are puzzled by the complexity of library integration, and the technical debt that comes along. The habit of graphically dragging libraries at random points into your IDE unfortunately conceals the actual complexity and significance of dependencies. Motivation While the drag and drop approach might work for a single developer and a simple project, it is not a reliable approach for project setup or even scenarios where no graphical access to the code exists (e.g. compiling on a server via SSH). The Classpath What actually happens when you compile a piece of software that uses a library, is that the java compiler sets out for journey to localize that library on your system. Unfortunately just writing the import statement, or calling a library is insufficient - the compiler has no clue where to actually find the library's byte code. What the compiler actually needs is a classpath reference: That is to say a reference, pin-pointing exactly to a location on your disk. The java classpath is an environment variably, listing all the places on your disk with potentially relevant libraries. You can think of the classpath a bit like the Operating System's PATH variable: It references all the software (respectively java libraries) installed, only in this case specifically for java libraries) When you drag a JAR into your IDE, under the hood the software performs a classpath extension. This is convenient if you are the only one coding. However, there are good reasons to keep track of all dependencies in a textual, structured way. Why now just download everything yourself? In principle you could manually download all libraries your project needs and manually alter the classpath . You could keep donwloading JARs and run the drag and drop approach for every developer who uses your code. In the best case you have a good software documentation that tells developers the complete list and where to get these JARs. Also you ensure the documentation is always up to date. Most likely you will eventually forget to list a dependency. Or one of the JARs is no longer available for download, or people will just refuse to download the long list of dependencies manually and dragging and dropping them every time they set up a new machine. There might also be a security issue in one of the libraries, but since you do not specify your dependencies in a standardized form auto-notifiers such as GitHubs Dependabot are not going to tell you. This is once more where maven comes to rescue. Maven has a dedicated part in the pom.xml file to indicate all dependencies textually. Since the pom.xml resides alongside the sources of your project, everyone who wants to work with your project automatically gets all dependencies, specified between the <dependencies>...</dependencies> tags. Nobody needs to manually download the decencies. Maven contacts official servers to download cryptographically signed versions of your dependencies, and adds them automatically to your classpath. Mavens Dependency Model The Maven pom.xml only stores a unique description of your dependencies, not the referenced libraries themselves. Luckily! Otherwise your repository would rapidly exceed a tolerable size. A dependency entry might look like this: <dependency> <groupId> commons-io </groupId> <artifactId> commons-io </artifactId> <version> 2.11.0 </version> </dependency> When Maven spots the above pom.xml entry, it will run the following procedure: Check if you already have the referenced dependency locally (maven has a local buffer in your homedirectory .m2 folder - It can be safely deleted if you run out of space.) If not yet found locally, maven contacts the official library servers and downloads the jar for you. It then stores it in your local buffer, so things are faster next time. Once the dependency resolved, Maven adds the locally downloaded artifact to your CLASSPATH . This means starting now, any occurrence of the library reference can now be correctly resolved. The great thing about this procedure is: If your pom.xml evolves, all developers have automatically the full list of all dependencies, and the right versions - without a single mouse click in IDE menus! Finding Libraries At this point you might how you can figure out the correct dependency entry for each and any java library you might ever need. Luckily this part has been made very simple for you. Most libraries are indexed in the official repos: If e.g. you are looking for the Apache Commons IO library, to conveniently load files from disk you can simply: Visit the maven central, a world wide collection of most public libraries: https://mvnrepository.com/ Search for the needed artifact: Type e.g. Apache Commons IO Click the version number: Usually you want the most recent one Copy and paste the dependency block into your pom.xml <dependency> <groupId> commons-io </groupId> <artifactId> commons-io </artifactId> <version> 2.11.0 </version> </dependency> Sample Library Use Now that maven has conveniently placed the commons-io library on your classpath you can directly access it from source code. (Don't forget to actually import the library!) package eu.kartoffelquadrat.liveprogramming ; import java.io.File ; import java.io.FileInputStream ; import java.io.IOException ; import org.apache.commons.io.IOUtils ; public class Launcher { public static void main ( String [] args ) throws IOException { // Program prints its own code... FileInputStream fisTargetFile = new FileInputStream ( new File ( \"/Users/schieder/Desktop/LiveProgramming/src/main/java/eu/kartoffelquadrat/liveprogramming/Launcher.java\" )); String targetFileStr = IOUtils . toString ( fisTargetFile , \"UTF-8\" ); System . out . println ( targetFileStr ); } }","title":"Dependency Management"},{"location":"dependencies/#compile-time-dependencies","text":"Most programmers at first are puzzled by the complexity of library integration, and the technical debt that comes along. The habit of graphically dragging libraries at random points into your IDE unfortunately conceals the actual complexity and significance of dependencies.","title":"Compile Time Dependencies"},{"location":"dependencies/#motivation","text":"While the drag and drop approach might work for a single developer and a simple project, it is not a reliable approach for project setup or even scenarios where no graphical access to the code exists (e.g. compiling on a server via SSH).","title":"Motivation"},{"location":"dependencies/#the-classpath","text":"What actually happens when you compile a piece of software that uses a library, is that the java compiler sets out for journey to localize that library on your system. Unfortunately just writing the import statement, or calling a library is insufficient - the compiler has no clue where to actually find the library's byte code. What the compiler actually needs is a classpath reference: That is to say a reference, pin-pointing exactly to a location on your disk. The java classpath is an environment variably, listing all the places on your disk with potentially relevant libraries. You can think of the classpath a bit like the Operating System's PATH variable: It references all the software (respectively java libraries) installed, only in this case specifically for java libraries) When you drag a JAR into your IDE, under the hood the software performs a classpath extension. This is convenient if you are the only one coding. However, there are good reasons to keep track of all dependencies in a textual, structured way.","title":"The Classpath"},{"location":"dependencies/#why-now-just-download-everything-yourself","text":"In principle you could manually download all libraries your project needs and manually alter the classpath . You could keep donwloading JARs and run the drag and drop approach for every developer who uses your code. In the best case you have a good software documentation that tells developers the complete list and where to get these JARs. Also you ensure the documentation is always up to date. Most likely you will eventually forget to list a dependency. Or one of the JARs is no longer available for download, or people will just refuse to download the long list of dependencies manually and dragging and dropping them every time they set up a new machine. There might also be a security issue in one of the libraries, but since you do not specify your dependencies in a standardized form auto-notifiers such as GitHubs Dependabot are not going to tell you. This is once more where maven comes to rescue. Maven has a dedicated part in the pom.xml file to indicate all dependencies textually. Since the pom.xml resides alongside the sources of your project, everyone who wants to work with your project automatically gets all dependencies, specified between the <dependencies>...</dependencies> tags. Nobody needs to manually download the decencies. Maven contacts official servers to download cryptographically signed versions of your dependencies, and adds them automatically to your classpath.","title":"Why now just download everything yourself?"},{"location":"dependencies/#mavens-dependency-model","text":"The Maven pom.xml only stores a unique description of your dependencies, not the referenced libraries themselves. Luckily! Otherwise your repository would rapidly exceed a tolerable size. A dependency entry might look like this: <dependency> <groupId> commons-io </groupId> <artifactId> commons-io </artifactId> <version> 2.11.0 </version> </dependency> When Maven spots the above pom.xml entry, it will run the following procedure: Check if you already have the referenced dependency locally (maven has a local buffer in your homedirectory .m2 folder - It can be safely deleted if you run out of space.) If not yet found locally, maven contacts the official library servers and downloads the jar for you. It then stores it in your local buffer, so things are faster next time. Once the dependency resolved, Maven adds the locally downloaded artifact to your CLASSPATH . This means starting now, any occurrence of the library reference can now be correctly resolved. The great thing about this procedure is: If your pom.xml evolves, all developers have automatically the full list of all dependencies, and the right versions - without a single mouse click in IDE menus!","title":"Mavens Dependency Model"},{"location":"dependencies/#finding-libraries","text":"At this point you might how you can figure out the correct dependency entry for each and any java library you might ever need. Luckily this part has been made very simple for you. Most libraries are indexed in the official repos: If e.g. you are looking for the Apache Commons IO library, to conveniently load files from disk you can simply: Visit the maven central, a world wide collection of most public libraries: https://mvnrepository.com/ Search for the needed artifact: Type e.g. Apache Commons IO Click the version number: Usually you want the most recent one Copy and paste the dependency block into your pom.xml <dependency> <groupId> commons-io </groupId> <artifactId> commons-io </artifactId> <version> 2.11.0 </version> </dependency>","title":"Finding Libraries"},{"location":"dependencies/#sample-library-use","text":"Now that maven has conveniently placed the commons-io library on your classpath you can directly access it from source code. (Don't forget to actually import the library!) package eu.kartoffelquadrat.liveprogramming ; import java.io.File ; import java.io.FileInputStream ; import java.io.IOException ; import org.apache.commons.io.IOUtils ; public class Launcher { public static void main ( String [] args ) throws IOException { // Program prints its own code... FileInputStream fisTargetFile = new FileInputStream ( new File ( \"/Users/schieder/Desktop/LiveProgramming/src/main/java/eu/kartoffelquadrat/liveprogramming/Launcher.java\" )); String targetFileStr = IOUtils . toString ( fisTargetFile , \"UTF-8\" ); System . out . println ( targetFileStr ); } }","title":"Sample Library Use"},{"location":"ideintegration/","text":"IDE Integration In this module I show you how to correctly set up a maven project in IntelliJ IDEA . While IntelliJ supports Maven projects out of the box, however there are a few pitfalls. Open the right Folder There are different ways to open a project, but the most reliable in my experience is to use the Open dialogue: Next select the root folder of your maven project ! Not src not any inner nested folder, select the root folder. That is the folder containing your pom.xml . Give IntelliJ a moment to index your project, there is a little progress bar in the top right. Then you should be good to continue. Link the pom File The changes made to the pom.xml file might not be all be taken into account out of the box. If you see this popup in the top right corner, click the twirly arrows to keep your IDE in sync with the content of your pom.xml file. Set up a Run Configuration When you open a class with a main method, IntelliJ will display little green triangles on the side bar. DO NOT CLICK THOSE! If you do, IntelliJ will interpret and run your code, but it will do so without taking into account any of your maven plugin configurations. This is not what you want, you might as well not use Maven then. Instead set up your own Maven-based run configuration: Click the Edit Configuration... button in the top right. Add a Maven Configuration , use the desired run command, e.g. clean package exec:java . Note the mvn keyword is implicit here. From here on the green triangle next to your custom run configuration automatically triggers the desired maven goals. Troubleshoot Q : I open the project with IntelliJ, but everything is underlined in red. A : The projet was not correctly opened. There are multiple potential fixes: Option 1) Reload pom.xml : Right click the file, then select Maven -> Reload Project . Option 2) Verify the JDK version: Select File -> Project Structure... . Verify 11.0.5 is selected in the Project and SDKs tab: Option 3) Invalidate IntelliJ caches: Select File -> Invalidate Caches... . Then select the first two checkboxes: Q : I cannot compile / run the project, the green button is greyed out. A : The project has no launch configuration by default, therefore the arrow in the top bar is not available. You have to create a maven run configuration first. Q : I've modified the pom.xml file as shown, but IntelliJ still does not seem to know about any dependencies. A : Sometimes the changes made to the pom.xml are not automatically detected. (See first question, pom.xml reload```.) Q : IntelliJ asks me whether I want to trust the project sources. Should I? A : Yes. This is just a security mechanism to prevent malicious code being executed on project import. The provided sources are all from us and can be trusted.","title":"IDE Integration"},{"location":"ideintegration/#ide-integration","text":"In this module I show you how to correctly set up a maven project in IntelliJ IDEA . While IntelliJ supports Maven projects out of the box, however there are a few pitfalls.","title":"IDE Integration"},{"location":"ideintegration/#open-the-right-folder","text":"There are different ways to open a project, but the most reliable in my experience is to use the Open dialogue: Next select the root folder of your maven project ! Not src not any inner nested folder, select the root folder. That is the folder containing your pom.xml . Give IntelliJ a moment to index your project, there is a little progress bar in the top right. Then you should be good to continue.","title":"Open the right Folder"},{"location":"ideintegration/#link-the-pom-file","text":"The changes made to the pom.xml file might not be all be taken into account out of the box. If you see this popup in the top right corner, click the twirly arrows to keep your IDE in sync with the content of your pom.xml file.","title":"Link the pom File"},{"location":"ideintegration/#set-up-a-run-configuration","text":"When you open a class with a main method, IntelliJ will display little green triangles on the side bar. DO NOT CLICK THOSE! If you do, IntelliJ will interpret and run your code, but it will do so without taking into account any of your maven plugin configurations. This is not what you want, you might as well not use Maven then. Instead set up your own Maven-based run configuration: Click the Edit Configuration... button in the top right. Add a Maven Configuration , use the desired run command, e.g. clean package exec:java . Note the mvn keyword is implicit here. From here on the green triangle next to your custom run configuration automatically triggers the desired maven goals.","title":"Set up a Run Configuration"},{"location":"ideintegration/#troubleshoot","text":"Q : I open the project with IntelliJ, but everything is underlined in red. A : The projet was not correctly opened. There are multiple potential fixes: Option 1) Reload pom.xml : Right click the file, then select Maven -> Reload Project . Option 2) Verify the JDK version: Select File -> Project Structure... . Verify 11.0.5 is selected in the Project and SDKs tab: Option 3) Invalidate IntelliJ caches: Select File -> Invalidate Caches... . Then select the first two checkboxes: Q : I cannot compile / run the project, the green button is greyed out. A : The project has no launch configuration by default, therefore the arrow in the top bar is not available. You have to create a maven run configuration first. Q : I've modified the pom.xml file as shown, but IntelliJ still does not seem to know about any dependencies. A : Sometimes the changes made to the pom.xml are not automatically detected. (See first question, pom.xml reload```.) Q : IntelliJ asks me whether I want to trust the project sources. Should I? A : Yes. This is just a security mechanism to prevent malicious code being executed on project import. The provided sources are all from us and can be trusted.","title":"Troubleshoot"},{"location":"layout/","text":"Project Layout In practice, a solid project setup should be more than just throwing code files at random place into a contrived project structure. Problem Statement Unfortunately I've experienced that in many student projects it comes down to exactly this: A chaotic project layout that has grown over time and no one wants to tamper with. To start a project you need to first click your way through IDE specific menus, then hopefully click on a green triangle start button and cross you fingers that the project will magically work. For little scripting codebases hammered out in a day this might work - but larger software projects often showcase a list of dependencies, and the barrier for new developers to set up their IDE should be as low as possible. You want a mechanism that allows you to compile and run your code reliably, no matter to platform or developer cloning the project - without tedious project configurations on every new clone. Maven's Contribution This is where maven enters the game. Maven replaces the click based IDE project configuration (where a developer sets up their project requirements and plugins via IDE menus), by just one central xml textual description : the pom.xml . Crafting a good pom.xml takes some effort - but the good news is: once the pom.xml is set up, no one ever needs to touch a UI menu again. Libraries and coding conventions are no longer stored in the project, but referenced form a central repository. This keeps your repo slim and allows every client to reliably pull all dependencies at compile time. Files and Folders The root of a maven project should roughly look like this: Sample project structure is a modified selection of the COMP303 Starter code. Before we go into the details, note that there are two important entities at root level: pom.xml which contains all project configuration. Almost everything presented over the next pages are snippets that extend this file. A src folder for all your source code, tests and resources. Depending on which configurations you add to your pom.xml , you might have additional content on top level. But for a start these two are the minimum compile requirements for your project at root level. SRC Layout Next let's look at the nested content of the src folder. Everything that carries a red marker in the capture above must be in place exactly as shown . If you alter that structure, your project simply is not valid and there are zero guarantees for what happens when you attempt to run it. Conventions: Your java sources goes into subfolders of src/main/java Your java tests go into subfolders of src/test/java Your resource files go into src/main/resources GroupId, ArtifactId, Packages In the test/java and src/java folder you see subfolders: eu/kartoffelquadrat/liveprogramming/comp303/corp . eu/kartoffelquadrat has a blue label. This on represents your groupId . The groupId is specific to the developer or code maintainer responsible for the project. By convention it is the inverted domain name of your affiliation. So for instance if you are a student at McGill you could use: ca/mcgill instead of eu/kartoffelquadrat . It can also be longer than two segments, but it seems to have become an unwritten convention to use two segments. Do not use eu/kartoffelquadrat for your projects. If in doubt, you can always use github.yourgithubname . liveprogramming is the artifactId . It has a yellow label. It describes the specific purpose of your project. For instance if you are developing a board game tic tac toe client, it could be ticTacToeClient . Optionally you can create further subfolders for sub-packages (purple label). E.g. if you have an MVC structure you can place parallel folders for model , view , control under your artifactId . Packages are optional for smaller projects, but for everything that has more than 5 classes, I'd recommend extra packages, just to keep things somewhat modular.","title":"Maven Project Layout"},{"location":"layout/#project-layout","text":"In practice, a solid project setup should be more than just throwing code files at random place into a contrived project structure.","title":"Project Layout"},{"location":"layout/#problem-statement","text":"Unfortunately I've experienced that in many student projects it comes down to exactly this: A chaotic project layout that has grown over time and no one wants to tamper with. To start a project you need to first click your way through IDE specific menus, then hopefully click on a green triangle start button and cross you fingers that the project will magically work. For little scripting codebases hammered out in a day this might work - but larger software projects often showcase a list of dependencies, and the barrier for new developers to set up their IDE should be as low as possible. You want a mechanism that allows you to compile and run your code reliably, no matter to platform or developer cloning the project - without tedious project configurations on every new clone.","title":"Problem Statement"},{"location":"layout/#mavens-contribution","text":"This is where maven enters the game. Maven replaces the click based IDE project configuration (where a developer sets up their project requirements and plugins via IDE menus), by just one central xml textual description : the pom.xml . Crafting a good pom.xml takes some effort - but the good news is: once the pom.xml is set up, no one ever needs to touch a UI menu again. Libraries and coding conventions are no longer stored in the project, but referenced form a central repository. This keeps your repo slim and allows every client to reliably pull all dependencies at compile time.","title":"Maven's Contribution"},{"location":"layout/#files-and-folders","text":"The root of a maven project should roughly look like this: Sample project structure is a modified selection of the COMP303 Starter code. Before we go into the details, note that there are two important entities at root level: pom.xml which contains all project configuration. Almost everything presented over the next pages are snippets that extend this file. A src folder for all your source code, tests and resources. Depending on which configurations you add to your pom.xml , you might have additional content on top level. But for a start these two are the minimum compile requirements for your project at root level.","title":"Files and Folders"},{"location":"layout/#src-layout","text":"Next let's look at the nested content of the src folder. Everything that carries a red marker in the capture above must be in place exactly as shown . If you alter that structure, your project simply is not valid and there are zero guarantees for what happens when you attempt to run it. Conventions: Your java sources goes into subfolders of src/main/java Your java tests go into subfolders of src/test/java Your resource files go into src/main/resources","title":"SRC Layout"},{"location":"layout/#groupid-artifactid-packages","text":"In the test/java and src/java folder you see subfolders: eu/kartoffelquadrat/liveprogramming/comp303/corp . eu/kartoffelquadrat has a blue label. This on represents your groupId . The groupId is specific to the developer or code maintainer responsible for the project. By convention it is the inverted domain name of your affiliation. So for instance if you are a student at McGill you could use: ca/mcgill instead of eu/kartoffelquadrat . It can also be longer than two segments, but it seems to have become an unwritten convention to use two segments. Do not use eu/kartoffelquadrat for your projects. If in doubt, you can always use github.yourgithubname . liveprogramming is the artifactId . It has a yellow label. It describes the specific purpose of your project. For instance if you are developing a board game tic tac toe client, it could be ticTacToeClient . Optionally you can create further subfolders for sub-packages (purple label). E.g. if you have an MVC structure you can place parallel folders for model , view , control under your artifactId . Packages are optional for smaller projects, but for everything that has more than 5 classes, I'd recommend extra packages, just to keep things somewhat modular.","title":"GroupId, ArtifactId, Packages"},{"location":"minimalpom/","text":"Minimal Pom, Hello World Once you have decided on your groupId , artifactId and also set up the required folder structure, the next step is to create a minimal pom.xml file. You can use below template as starting point, although you will need to make some minor changes . Pom Template Create the pom.xml at top level of your project, then paste in the below template content: <?xml version=\"1.0\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> eu.kartoffelquadrat </groupId> <artifactId> projectname </artifactId> <packaging> jar </packaging> <version> 1.0 </version> <name> printer </name> <url> http://maven.apache.org </url> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <maven.compiler.target> 1.8 </maven.compiler.target> <maven.compiler.source> 1.8 </maven.compiler.source> <build.name> ProjectNameInCamelCase </build.name> </properties> <!-- main developer --> <developers> <developer> <name> Maximilian Schiedermeier </name> <email> maximilian.schiedermeier@mcgill.ca </email> <organization> kartoffelquadrat.eu </organization> <organizationUrl> https://github.com/kartoffelquadrat </organizationUrl> </developer> </developers> <!-- legal --> <licenses> <license> <name> MIT License </name> <url> http://www.opensource.org/licenses/mit-license.php </url> <distribution> repo </distribution> </license> </licenses> <dependencies> </dependencies> <build> <!-- Override default name of generated artifacts --> <finalName> ${build.name} </finalName> <plugins> </plugins> </build> </project> Changes Next go over below list and make sure to updated the indicated fields: Replace the groupId tag content by something that describes your group . Replace the artifactId tag content by something that describes your project purpose . Update the name tag to a single human readable word, describing your product. Update the build.name variable to a camelCase description of your product, as you want the generated executable file to be named. Update the developer name and info. Choose a license, or remove the license block if you want to reserve all rights. Hello World Next create a file Launcher.java in the lowest level of your src/main/java/... folder with the following content: package eu.kartoffelquadrat.liveprogramming ; public class Launcher { public static void main ( String [] args ) { System . out . println ( \"Hello, World!\" ); } } Note : Make sure the package matches your groupid + artifactid + any other subpackages you have in your folder structure!","title":"Minimal Pom"},{"location":"minimalpom/#minimal-pom-hello-world","text":"Once you have decided on your groupId , artifactId and also set up the required folder structure, the next step is to create a minimal pom.xml file. You can use below template as starting point, although you will need to make some minor changes .","title":"Minimal Pom, Hello World"},{"location":"minimalpom/#pom-template","text":"Create the pom.xml at top level of your project, then paste in the below template content: <?xml version=\"1.0\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> eu.kartoffelquadrat </groupId> <artifactId> projectname </artifactId> <packaging> jar </packaging> <version> 1.0 </version> <name> printer </name> <url> http://maven.apache.org </url> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <maven.compiler.target> 1.8 </maven.compiler.target> <maven.compiler.source> 1.8 </maven.compiler.source> <build.name> ProjectNameInCamelCase </build.name> </properties> <!-- main developer --> <developers> <developer> <name> Maximilian Schiedermeier </name> <email> maximilian.schiedermeier@mcgill.ca </email> <organization> kartoffelquadrat.eu </organization> <organizationUrl> https://github.com/kartoffelquadrat </organizationUrl> </developer> </developers> <!-- legal --> <licenses> <license> <name> MIT License </name> <url> http://www.opensource.org/licenses/mit-license.php </url> <distribution> repo </distribution> </license> </licenses> <dependencies> </dependencies> <build> <!-- Override default name of generated artifacts --> <finalName> ${build.name} </finalName> <plugins> </plugins> </build> </project>","title":"Pom Template"},{"location":"minimalpom/#changes","text":"Next go over below list and make sure to updated the indicated fields: Replace the groupId tag content by something that describes your group . Replace the artifactId tag content by something that describes your project purpose . Update the name tag to a single human readable word, describing your product. Update the build.name variable to a camelCase description of your product, as you want the generated executable file to be named. Update the developer name and info. Choose a license, or remove the license block if you want to reserve all rights.","title":"Changes"},{"location":"minimalpom/#hello-world","text":"Next create a file Launcher.java in the lowest level of your src/main/java/... folder with the following content: package eu.kartoffelquadrat.liveprogramming ; public class Launcher { public static void main ( String [] args ) { System . out . println ( \"Hello, World!\" ); } } Note : Make sure the package matches your groupid + artifactid + any other subpackages you have in your folder structure!","title":"Hello World"},{"location":"pmd/","text":"PMD PMD is a static source code analyzer that can be highly configured to detect issues on a wide range, from poor coding, missing documentation to severe security or performance flaws. PMD can also be added to IntelliJ as graphical plugin . Configuration Add the following plugin to your pom.xml : <!-- PMD static code analysis --> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-pmd-plugin </artifactId> <version> 3.13.0 </version> <configuration> <rulesets> <!-- full list: bestpractices, codestyle, design, documentation, errorprone, multithreading, performance--> <ruleset> /category/java/bestpractices.xml </ruleset> </rulesets> <!-- failOnViolation is actually true by default, but can be disabled --> <failOnViolation> true </failOnViolation> <!-- printFailingErrors is pretty useful --> <printFailingErrors> true </printFailingErrors> <linkXRef> false </linkXRef> </configuration> <executions> <execution> <goals> <goal> check </goal> </goals> <!-- Enforce the pmd:check goal is auto-executed during package phase--> <phase> package </phase> </execution> </executions> </plugin> Invokation: The plugin is configured to be automcatically executed on every mvn clean package . To run the code analysis without the full package phase, type: mvn clean pmd:check . Tweaks Above default configuration only tests for codestyle violations. To get the full range of feedback, enable the full rulesets list: <ruleset> /category/java/bestpractices.xml </ruleset> <ruleset> /category/java/codestyle.xml </ruleset> <ruleset> /category/java/design.xml </ruleset> <ruleset> /category/java/documentation.xml </ruleset> <ruleset> /category/java/errorprone.xml </ruleset> <ruleset> /category/java/multithreading.xml </ruleset> <ruleset> /category/java/performance.xml </ruleset>","title":"Project Meets Deadline"},{"location":"pmd/#pmd","text":"PMD is a static source code analyzer that can be highly configured to detect issues on a wide range, from poor coding, missing documentation to severe security or performance flaws. PMD can also be added to IntelliJ as graphical plugin .","title":"PMD"},{"location":"pmd/#configuration","text":"Add the following plugin to your pom.xml : <!-- PMD static code analysis --> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-pmd-plugin </artifactId> <version> 3.13.0 </version> <configuration> <rulesets> <!-- full list: bestpractices, codestyle, design, documentation, errorprone, multithreading, performance--> <ruleset> /category/java/bestpractices.xml </ruleset> </rulesets> <!-- failOnViolation is actually true by default, but can be disabled --> <failOnViolation> true </failOnViolation> <!-- printFailingErrors is pretty useful --> <printFailingErrors> true </printFailingErrors> <linkXRef> false </linkXRef> </configuration> <executions> <execution> <goals> <goal> check </goal> </goals> <!-- Enforce the pmd:check goal is auto-executed during package phase--> <phase> package </phase> </execution> </executions> </plugin> Invokation: The plugin is configured to be automcatically executed on every mvn clean package . To run the code analysis without the full package phase, type: mvn clean pmd:check .","title":"Configuration"},{"location":"pmd/#tweaks","text":"Above default configuration only tests for codestyle violations. To get the full range of feedback, enable the full rulesets list: <ruleset> /category/java/bestpractices.xml </ruleset> <ruleset> /category/java/codestyle.xml </ruleset> <ruleset> /category/java/design.xml </ruleset> <ruleset> /category/java/documentation.xml </ruleset> <ruleset> /category/java/errorprone.xml </ruleset> <ruleset> /category/java/multithreading.xml </ruleset> <ruleset> /category/java/performance.xml </ruleset>","title":"Tweaks"},{"location":"profiles/","text":"","title":"Profiles"},{"location":"run/","text":"Run The whole point of Maven is that you can build your software reliably, no matter the environment - this also includes settings where you have no graphical access, and maybe not even an IDE. The default way to compile a maven project is therefore by command line. Run Plugins and Commands To run a program you need to have your pom.xml point to the desired launcher class. There can also be programs with multiple launcher classes, but this corner case we deal with later. On top, the startup procedure is often also dependent on the framework or library you are using. Especially GUI and reflective libraries tend to overload the default javaagent and therefore also bring their own plugins that need to be added to the pom.xml . Plugins Maven plugins, like dependencies are (once included in the pom.xml ) downloaded and added to the .m2 directory and classpath. However plugins are commonly compile-time dependencies, not run-time dependencies like libraries. Plugins merely target a modification of the default build and run process. In the default pom.xml you already see an empty section for plugins: <plugins> </plugins> All xml snippets shown in the following go directly within these tags. Run Plugin Samples Below you find sample run-plugins for Vanilla , Spring Boot and JavaFX projects. There are many more, but this selection should give you a good illustration of the procedure. Note how every plugin also slightly alters the launch command! (Command after xml snippet) Vanilla / No Frameworks Spring Boot Java FX <plugin> <groupId>org.codehaus.mojo</groupId> <artifactId>exec-maven-plugin</artifactId> <version>1.6.0</version> <executions> <execution> <goals> <goal>java</goal> </goals> </execution> </executions> <configuration> <mainClass>eu.kartoffelquadrat.printer.PrinterVsLogger</mainClass> </configuration> </plugin> Start your program with: mvn clean package exec:java ---No Plugins Needed: Launcher class is auto detected by annotation--- Start your program with: mvn clean package spring-boot:run <plugin> <groupId>org.openjfx</groupId> <artifactId>javafx-maven-plugin</artifactId> <version>0.0.8</version> <configuration> <mainClass>eu.kartoffelquadrat.javafxhelloworld.Launcher</mainClass> </configuration> </plugin> Start your program with: mvn clean package javafx:run","title":"Direct Run"},{"location":"run/#run","text":"The whole point of Maven is that you can build your software reliably, no matter the environment - this also includes settings where you have no graphical access, and maybe not even an IDE. The default way to compile a maven project is therefore by command line.","title":"Run"},{"location":"run/#run-plugins-and-commands","text":"To run a program you need to have your pom.xml point to the desired launcher class. There can also be programs with multiple launcher classes, but this corner case we deal with later. On top, the startup procedure is often also dependent on the framework or library you are using. Especially GUI and reflective libraries tend to overload the default javaagent and therefore also bring their own plugins that need to be added to the pom.xml .","title":"Run Plugins and Commands"},{"location":"run/#plugins","text":"Maven plugins, like dependencies are (once included in the pom.xml ) downloaded and added to the .m2 directory and classpath. However plugins are commonly compile-time dependencies, not run-time dependencies like libraries. Plugins merely target a modification of the default build and run process. In the default pom.xml you already see an empty section for plugins: <plugins> </plugins> All xml snippets shown in the following go directly within these tags.","title":"Plugins"},{"location":"run/#run-plugin-samples","text":"Below you find sample run-plugins for Vanilla , Spring Boot and JavaFX projects. There are many more, but this selection should give you a good illustration of the procedure. Note how every plugin also slightly alters the launch command! (Command after xml snippet) Vanilla / No Frameworks Spring Boot Java FX <plugin> <groupId>org.codehaus.mojo</groupId> <artifactId>exec-maven-plugin</artifactId> <version>1.6.0</version> <executions> <execution> <goals> <goal>java</goal> </goals> </execution> </executions> <configuration> <mainClass>eu.kartoffelquadrat.printer.PrinterVsLogger</mainClass> </configuration> </plugin> Start your program with: mvn clean package exec:java ---No Plugins Needed: Launcher class is auto detected by annotation--- Start your program with: mvn clean package spring-boot:run <plugin> <groupId>org.openjfx</groupId> <artifactId>javafx-maven-plugin</artifactId> <version>0.0.8</version> <configuration> <mainClass>eu.kartoffelquadrat.javafxhelloworld.Launcher</mainClass> </configuration> </plugin> Start your program with: mvn clean package javafx:run","title":"Run Plugin Samples"},{"location":"signature/","text":"","title":"Signature"}]}