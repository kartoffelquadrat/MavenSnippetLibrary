{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Maven Snippet Library Maven is a powerful build tool. Yet the many configuration options it offers are often overwhelming to newcomers. Even setting up a simple project \"that just works\" can be at first a little frustrating. About this Page This web page hosts a step by step guide, that takes you from a minimal valid configuration to advanced features, all with tested and proven snippets . Contributions Feel free to report errors or improvement suggestions via merge requests to https://github.com/kartoffelqudrat/MavenSnippetLibrary . Note that you need mkdocs to build the webpage. So make sure to edit the markdowns, not the HTMLS. Most of all have lots of fun and happy coding, Max","title":"Welcome"},{"location":"#maven-snippet-library","text":"Maven is a powerful build tool. Yet the many configuration options it offers are often overwhelming to newcomers. Even setting up a simple project \"that just works\" can be at first a little frustrating.","title":"Maven Snippet Library"},{"location":"#about-this-page","text":"This web page hosts a step by step guide, that takes you from a minimal valid configuration to advanced features, all with tested and proven snippets .","title":"About this Page"},{"location":"#contributions","text":"Feel free to report errors or improvement suggestions via merge requests to https://github.com/kartoffelqudrat/MavenSnippetLibrary . Note that you need mkdocs to build the webpage. So make sure to edit the markdowns, not the HTMLS. Most of all have lots of fun and happy coding, Max","title":"Contributions"},{"location":"artifactbuild/","text":"Artifact Build Often you want to run a software without first cloning or building the sources. In fact, almost any time you download a software from the internet you receive a precompiled release rather than source code. It is actually not so trivial to obtain such a standalone executable that comes a single file, with all its dependencies included. Maven comes with powerful mechanisms to build your project to a wholesome Java Archive (JAR) file. In this case, all dependencies are included - however the customer still needs a Java Runtime Environment (JRE). Note: It is also possible to include the JRE dependencies themselves. However, for simplicity this is not covered in this guide. Additional info on true platform specific standalones e.g. Mac can be found here . Creating a JAR with all dependencies Once more this is a goal best achieved by help of targeted plugins. Similar to the Direct Run module we needed to provide a pointer to the desired launcher class, we need to tell the jar-creating plugin about the entry point to our code. Below are three snippets for Vanilla , Spring Boot and JavaFX projects. There are many more plugins for further frameworks, but this selection should give you a good illustration of the procedure. Add the desired plugin to your pom.xml Then compile / build a self contained jar with: mvn clean package Finally run the produced jar: java -jar target/whatever.jar Vanilla / No Frameworks Spring Boot Java FX <plugin> <artifactId> maven-assembly-plugin </artifactId> <executions> <execution> <phase> package </phase> <goals> <goal> single </goal> </goals> </execution> </executions> <configuration> <archive> <manifest> <addClasspath> true </addClasspath> <mainClass> eu.kartoffelquadrat.zoo.Launcher </mainClass> </manifest> </archive> <descriptorRefs> <descriptorRef> jar-with-dependencies </descriptorRef> </descriptorRefs> <finalName> AcquireBanker </finalName> <appendAssemblyId> false </appendAssemblyId> </configuration> </plugin> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> <configuration> <fork> true </fork> <mainClass> eu.kartoffelquadrat.zoo.RestLauncher </mainClass> </configuration> <executions> <execution> <goals> <goal> repackage </goal> </goals> </execution> </executions> </plugin> <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.4.0 </version> <executions> <execution> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <transformers> <transformer implementation= \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" > <mainClass> eu.kartoffelquadrat.javafxhelloworld.SuperLauncher </mainClass> </transformer> </transformers> </configuration> </execution> </executions> </plugin>","title":"Artifact Build"},{"location":"artifactbuild/#artifact-build","text":"Often you want to run a software without first cloning or building the sources. In fact, almost any time you download a software from the internet you receive a precompiled release rather than source code. It is actually not so trivial to obtain such a standalone executable that comes a single file, with all its dependencies included. Maven comes with powerful mechanisms to build your project to a wholesome Java Archive (JAR) file. In this case, all dependencies are included - however the customer still needs a Java Runtime Environment (JRE). Note: It is also possible to include the JRE dependencies themselves. However, for simplicity this is not covered in this guide. Additional info on true platform specific standalones e.g. Mac can be found here .","title":"Artifact Build"},{"location":"artifactbuild/#creating-a-jar-with-all-dependencies","text":"Once more this is a goal best achieved by help of targeted plugins. Similar to the Direct Run module we needed to provide a pointer to the desired launcher class, we need to tell the jar-creating plugin about the entry point to our code. Below are three snippets for Vanilla , Spring Boot and JavaFX projects. There are many more plugins for further frameworks, but this selection should give you a good illustration of the procedure. Add the desired plugin to your pom.xml Then compile / build a self contained jar with: mvn clean package Finally run the produced jar: java -jar target/whatever.jar Vanilla / No Frameworks Spring Boot Java FX <plugin> <artifactId> maven-assembly-plugin </artifactId> <executions> <execution> <phase> package </phase> <goals> <goal> single </goal> </goals> </execution> </executions> <configuration> <archive> <manifest> <addClasspath> true </addClasspath> <mainClass> eu.kartoffelquadrat.zoo.Launcher </mainClass> </manifest> </archive> <descriptorRefs> <descriptorRef> jar-with-dependencies </descriptorRef> </descriptorRefs> <finalName> AcquireBanker </finalName> <appendAssemblyId> false </appendAssemblyId> </configuration> </plugin> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> <configuration> <fork> true </fork> <mainClass> eu.kartoffelquadrat.zoo.RestLauncher </mainClass> </configuration> <executions> <execution> <goals> <goal> repackage </goal> </goals> </execution> </executions> </plugin> <plugin> <artifactId> maven-shade-plugin </artifactId> <version> 3.4.0 </version> <executions> <execution> <phase> package </phase> <goals> <goal> shade </goal> </goals> <configuration> <transformers> <transformer implementation= \"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\" > <mainClass> eu.kartoffelquadrat.javafxhelloworld.SuperLauncher </mainClass> </transformer> </transformers> </configuration> </execution> </executions> </plugin>","title":"Creating a JAR with all dependencies"},{"location":"bestpractices/","text":"Build Best Practices Just because a program seemingly works, it does not mean it is free of errors or well written. However, while Tests, documentation and style checks are by themselves not a guarantee for good code, the are generally considered a non-optional prerequisite. Below I show you which plugins you can integrate into your project to enforce this minimal quality on your code. Note: Very likely your program will at first no longer run once you enable these plugins. You might be tempted to say Nah, does not work - I'll remove this BLEEP . However, keep in mind that you then only fix the symptoms, not the actual code issues you just were told about. Better: take an hour or two, carefully read through the warnings you received, then change your code so the warnings no longer appear. Checkstyle First of all you will need a checkstyle configuration file. I recommend the one by google . Place it in your project's root directory, right next to the pom.xml . Next you need to enable the Maven Checkstyle Plugin in your pom.xml . Paste the below snippet somewhere between your pom.xml s <plugins>...</plugins> tags. <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-checkstyle-plugin </artifactId> <version> 3.2.0 </version> <configuration> <configLocation> google_checks.xml </configLocation> <consoleOutput> true </consoleOutput> <violationSeverity> warning </violationSeverity> <failOnViolation> true </failOnViolation> <failsOnError> true </failsOnError> <linkXRef> false </linkXRef> </configuration> <executions> <execution> <id> validate </id> <phase> validate </phase> <goals> <goal> check </goal> </goals> </execution> </executions> </plugin> Effect Your program will not start unless your code complies to all checkstyle rules. This even includes formatting. You really do not want to have two developers in your team who use different auto-formats and produce massive merge commits on every commit. This plugin can be a real and trouble time-saver. JavaDoc Parameter Check Enable the JavaDoc Plugin in your pom.xml . Paste the below snippet somewhere between your pom.xml s <plugins>...</plugins> tags. <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-javadoc-plugin </artifactId> <version> 3.4.0 </version> <configuration> <source> 8 </source> <javadocExecutable> ${java.home}/bin/javadoc </javadocExecutable> <reportOutputDirectory> ${project.reporting.outputDirectory}/docs </reportOutputDirectory> <destDir> docs </destDir> </configuration> <executions> <execution> <id> attach-javadocs </id> <goals> <goal> jar </goal> </goals> <configuration> <failOnWarnings> true </failOnWarnings> </configuration> </execution> </executions> </plugin> Effect Generates to top level docs folder, using the JavaDoc in your source code. This one is very strict. The failOnWarnings : true entry ensures your program does not compile unless all parameters are documented. So if you forgot a single javadoc parameter documentation you cannot run your code. This may sound tedious, but it actually ensures your codebase does not grow and uncontrolled while getting harder and harder to understand. Unit Tests Passing Enforce the passing of all Unit Tests via your pom.xml . Unlike the previous, this one is enabled via a plugin in combination with a test scoped dependency . Paste the below snippet somewhere between your pom.xml s respective <dependencies>...</dependencies> and <plugins>...</plugins> tags. Dependency snippet: <dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> 4.10 </version> <scope> test </scope> </dependency> Plugin snippet: <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.22.2 </version> </plugin> Effect Refuses build unless all unit tests defines in src/test/java pass. Here is how to create a sample unit test: package eu.kartoffelquadrat.whatever ; import org.junit.Test ; /** * Simple demo test... * * @author Maximilian Schiedermeier */ public class PrinterVsLoggerTest { @Test public void testPrinter () { AssertTrue (...); } }","title":"Best Practices"},{"location":"bestpractices/#build-best-practices","text":"Just because a program seemingly works, it does not mean it is free of errors or well written. However, while Tests, documentation and style checks are by themselves not a guarantee for good code, the are generally considered a non-optional prerequisite. Below I show you which plugins you can integrate into your project to enforce this minimal quality on your code. Note: Very likely your program will at first no longer run once you enable these plugins. You might be tempted to say Nah, does not work - I'll remove this BLEEP . However, keep in mind that you then only fix the symptoms, not the actual code issues you just were told about. Better: take an hour or two, carefully read through the warnings you received, then change your code so the warnings no longer appear.","title":"Build Best Practices"},{"location":"bestpractices/#checkstyle","text":"First of all you will need a checkstyle configuration file. I recommend the one by google . Place it in your project's root directory, right next to the pom.xml . Next you need to enable the Maven Checkstyle Plugin in your pom.xml . Paste the below snippet somewhere between your pom.xml s <plugins>...</plugins> tags. <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-checkstyle-plugin </artifactId> <version> 3.2.0 </version> <configuration> <configLocation> google_checks.xml </configLocation> <consoleOutput> true </consoleOutput> <violationSeverity> warning </violationSeverity> <failOnViolation> true </failOnViolation> <failsOnError> true </failsOnError> <linkXRef> false </linkXRef> </configuration> <executions> <execution> <id> validate </id> <phase> validate </phase> <goals> <goal> check </goal> </goals> </execution> </executions> </plugin>","title":"Checkstyle"},{"location":"bestpractices/#effect","text":"Your program will not start unless your code complies to all checkstyle rules. This even includes formatting. You really do not want to have two developers in your team who use different auto-formats and produce massive merge commits on every commit. This plugin can be a real and trouble time-saver.","title":"Effect"},{"location":"bestpractices/#javadoc-parameter-check","text":"Enable the JavaDoc Plugin in your pom.xml . Paste the below snippet somewhere between your pom.xml s <plugins>...</plugins> tags. <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-javadoc-plugin </artifactId> <version> 3.4.0 </version> <configuration> <source> 8 </source> <javadocExecutable> ${java.home}/bin/javadoc </javadocExecutable> <reportOutputDirectory> ${project.reporting.outputDirectory}/docs </reportOutputDirectory> <destDir> docs </destDir> </configuration> <executions> <execution> <id> attach-javadocs </id> <goals> <goal> jar </goal> </goals> <configuration> <failOnWarnings> true </failOnWarnings> </configuration> </execution> </executions> </plugin>","title":"JavaDoc Parameter Check"},{"location":"bestpractices/#effect_1","text":"Generates to top level docs folder, using the JavaDoc in your source code. This one is very strict. The failOnWarnings : true entry ensures your program does not compile unless all parameters are documented. So if you forgot a single javadoc parameter documentation you cannot run your code. This may sound tedious, but it actually ensures your codebase does not grow and uncontrolled while getting harder and harder to understand.","title":"Effect"},{"location":"bestpractices/#unit-tests-passing","text":"Enforce the passing of all Unit Tests via your pom.xml . Unlike the previous, this one is enabled via a plugin in combination with a test scoped dependency . Paste the below snippet somewhere between your pom.xml s respective <dependencies>...</dependencies> and <plugins>...</plugins> tags. Dependency snippet: <dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> 4.10 </version> <scope> test </scope> </dependency> Plugin snippet: <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.22.2 </version> </plugin>","title":"Unit Tests Passing"},{"location":"bestpractices/#effect_2","text":"Refuses build unless all unit tests defines in src/test/java pass. Here is how to create a sample unit test: package eu.kartoffelquadrat.whatever ; import org.junit.Test ; /** * Simple demo test... * * @author Maximilian Schiedermeier */ public class PrinterVsLoggerTest { @Test public void testPrinter () { AssertTrue (...); } }","title":"Effect"},{"location":"dependencies/","text":"Compile Time Dependencies Most programmers at first are puzzled by the complexity of library integration. The habit of graphically dragging libraries at random points into your IDE unfortunately conceals the actual complexity of code dependencies. Motivation While the drag and drop approach might work for a single developer and a simple project, it is not a reliable approach for fast workstation setup or even scenarios where no graphical access to the code exists (e.g. compiling on a server via SSH). The Classpath What actually happens when you try to compile a piece of software (depending on a library call) is that the java compiler sets out for journey to localize the library you are referring to. Unfortunately by just writing the import statement, or calling a library the compiler has no clue where to actually find the library byte code. What the compiler actually needs is a classpath reference, pin-pointing exactly to a valid location on disk. (The classpath is a bit like the PATH variable on your operating system. It indexes all the software installed, only in this case specifically for java libraries) In principle you could manually download all libraries your project needs and manually alter the classpath every time you compile or run your software. When you drag and drop a library jar file on your IDE that process might happen implicitly. The problem is that drag and drop only solves the issue for the very machine you are working on, not for any other developer who clones your project. This is once more where maven comes to rescue. Maven has a dedicated part in the pom.xml file to indicate all dependencies textually. Since the pom.xml resides alongside the sources of your project, everyone who want to work with your project automatically gets all it's dependencies, stored between the <dependencies>...</dependencies> tags. Mavens Dependency Model The Maven pom.xml only stores a unique description of your dependencies, not the referenced libraries themselves. Luckily! Otherwise your repository would rapidly exceed a tolerable size. A dependency entry might look like this: <dependency> <groupId> commons-io </groupId> <artifactId> commons-io </artifactId> <version> 2.11.0 </version> </dependency> When Maven finds the above entry, it will run the following procedure: Check if you already have the referenced dependency locally (maven has a local buffer in your homedirectory .m2 folder) If not yet found locally, maven contacts the official library servers and downloads the jar for you. It then stores it in your local buffer, so things are faster next time. Once the dependency resolved, Maven adds the locally downloaded artifact to your CLASSPATH . This means starting now, any occurence of the library reference can now be correctly resolved. The great thing about this procedure is: If your pom.xml evolves, all developers have automatically the full list of all dependencies, and the right versions - without a single mouse click in IDE menus! Finding Libraries At this point you might wonder how on earth you are supposed to figure out the correct dependency entry for each and any java library you might ever need. Luckily this part has been made very simple for you: If e.g. you are looking for the Apache Commons IO library, to conveniently load files from disk you can simply: Visit the maven central, a world wide collection of most public libraries: https://mvnrepository.com/ Search for the needed artifact: Type e.g. Apache Commons IO Click the version number: Usually you want the most recent one Copy and paste the dependency block into your pom.xml <dependency> <groupId> commons-io </groupId> <artifactId> commons-io </artifactId> <version> 2.11.0 </version> </dependency> Sample Library Use Now that maven has conveniently placed the commons-io library on your classpath you can directly access it from source code. (Don't forget to actually import the library!) package eu.kartoffelquadrat.liveprogramming ; import java.io.File ; import java.io.FileInputStream ; import java.io.IOException ; import org.apache.commons.io.IOUtils ; public class Launcher { public static void main ( String [] args ) throws IOException { // Program prints its own code... FileInputStream fisTargetFile = new FileInputStream ( new File ( \"/Users/schieder/Desktop/LiveProgramming/src/main/java/eu/kartoffelquadrat/liveprogramming/Launcher.java\" )); String targetFileStr = IOUtils . toString ( fisTargetFile , \"UTF-8\" ); System . out . println ( targetFileStr ); } }","title":"Dependency Management"},{"location":"dependencies/#compile-time-dependencies","text":"Most programmers at first are puzzled by the complexity of library integration. The habit of graphically dragging libraries at random points into your IDE unfortunately conceals the actual complexity of code dependencies.","title":"Compile Time Dependencies"},{"location":"dependencies/#motivation","text":"While the drag and drop approach might work for a single developer and a simple project, it is not a reliable approach for fast workstation setup or even scenarios where no graphical access to the code exists (e.g. compiling on a server via SSH).","title":"Motivation"},{"location":"dependencies/#the-classpath","text":"What actually happens when you try to compile a piece of software (depending on a library call) is that the java compiler sets out for journey to localize the library you are referring to. Unfortunately by just writing the import statement, or calling a library the compiler has no clue where to actually find the library byte code. What the compiler actually needs is a classpath reference, pin-pointing exactly to a valid location on disk. (The classpath is a bit like the PATH variable on your operating system. It indexes all the software installed, only in this case specifically for java libraries) In principle you could manually download all libraries your project needs and manually alter the classpath every time you compile or run your software. When you drag and drop a library jar file on your IDE that process might happen implicitly. The problem is that drag and drop only solves the issue for the very machine you are working on, not for any other developer who clones your project. This is once more where maven comes to rescue. Maven has a dedicated part in the pom.xml file to indicate all dependencies textually. Since the pom.xml resides alongside the sources of your project, everyone who want to work with your project automatically gets all it's dependencies, stored between the <dependencies>...</dependencies> tags.","title":"The Classpath"},{"location":"dependencies/#mavens-dependency-model","text":"The Maven pom.xml only stores a unique description of your dependencies, not the referenced libraries themselves. Luckily! Otherwise your repository would rapidly exceed a tolerable size. A dependency entry might look like this: <dependency> <groupId> commons-io </groupId> <artifactId> commons-io </artifactId> <version> 2.11.0 </version> </dependency> When Maven finds the above entry, it will run the following procedure: Check if you already have the referenced dependency locally (maven has a local buffer in your homedirectory .m2 folder) If not yet found locally, maven contacts the official library servers and downloads the jar for you. It then stores it in your local buffer, so things are faster next time. Once the dependency resolved, Maven adds the locally downloaded artifact to your CLASSPATH . This means starting now, any occurence of the library reference can now be correctly resolved. The great thing about this procedure is: If your pom.xml evolves, all developers have automatically the full list of all dependencies, and the right versions - without a single mouse click in IDE menus!","title":"Mavens Dependency Model"},{"location":"dependencies/#finding-libraries","text":"At this point you might wonder how on earth you are supposed to figure out the correct dependency entry for each and any java library you might ever need. Luckily this part has been made very simple for you: If e.g. you are looking for the Apache Commons IO library, to conveniently load files from disk you can simply: Visit the maven central, a world wide collection of most public libraries: https://mvnrepository.com/ Search for the needed artifact: Type e.g. Apache Commons IO Click the version number: Usually you want the most recent one Copy and paste the dependency block into your pom.xml <dependency> <groupId> commons-io </groupId> <artifactId> commons-io </artifactId> <version> 2.11.0 </version> </dependency>","title":"Finding Libraries"},{"location":"dependencies/#sample-library-use","text":"Now that maven has conveniently placed the commons-io library on your classpath you can directly access it from source code. (Don't forget to actually import the library!) package eu.kartoffelquadrat.liveprogramming ; import java.io.File ; import java.io.FileInputStream ; import java.io.IOException ; import org.apache.commons.io.IOUtils ; public class Launcher { public static void main ( String [] args ) throws IOException { // Program prints its own code... FileInputStream fisTargetFile = new FileInputStream ( new File ( \"/Users/schieder/Desktop/LiveProgramming/src/main/java/eu/kartoffelquadrat/liveprogramming/Launcher.java\" )); String targetFileStr = IOUtils . toString ( fisTargetFile , \"UTF-8\" ); System . out . println ( targetFileStr ); } }","title":"Sample Library Use"},{"location":"ideintegration/","text":"IDE Integration Coming soon!","title":"IDE Integration"},{"location":"ideintegration/#ide-integration","text":"Coming soon!","title":"IDE Integration"},{"location":"layout/","text":"Project Layout You might be used to a discovery like project setup, where you just throw in you code files at random place into the project, then hopefully click a green triangle start button in your IDE and cross you fingers it will magically work. While this may work for tiny projects or little scripting codebases that you hammer out in a day, bigger software projects often have a long list of requirements and likewise are expected to compile and run reliable no matter to platform or developer cloning the project. This is where maven enters the game. Maven replaces the click based project configuration (where a developer sets up their project via IDE menus), by a central xml textual description, the `pom.xml . The good news is: Once the pom.xml is set up, no one ever needs to touch a UI menu again. Files and Folders The root of a maven project should roughly look like this: Before we go into the details, note that there are two important entires at root level: pom.xml which contains all project configuration. Almost everything presented on this webpage are snippets that extend this file. A src folder, all your source code, tests, even resources go somewhere into that folder. Depending on which configurations you add to your pom.xml , you might have additional content on top level. But for a start these are the minimum requirement for your project at root level. Next let's look at the nested content of the src folder. Everything that carries a red marker in the capture above must be in place exactly as shown . If you alter that structure, your project simply is not valid and there are zero guarantees for what happens when someone else attempts to build and run it. Your java sources go into src/main/java Your java tests fo into src/test/java Your resource files go into src/main/resources GroupId, ArtifactId, Packages In the test/java and src/java folder you see subfolders: eu/kartoffelquadrat/printer . eu/kartoffelquadrat has a blue label. This on represents your groupId . The groupId is specific to the developer (or team of developers) responsible for the project. By convention it is the inverted domain name of your affiliation. So for instance if you are a student at McGill you could use: ca/mcgill instead of eu/kartoffelquadrat . It can also be longer than two segments, but it seems to have become an unwritten convention to use two segments. Do not use eu/kartoffelquadrat for your projects. That domain is owned by me, so you better not pretend to release software on my behalf. ;) liveprogramming is the artifactId . It has a yellow label. It describes the specific purpose of your project. For instance if you are developing a board game tic tac toe client, it could be ticTacToeClient . Optionally you can create further subfolders for sub-packages (purple label). E.g. if you have an MVC structure you can place parallel folders for model , view , control under your artifactId . Packages are optional for smaller projects, but for everything that has more than 5 classes, things can get very confusing without packages.","title":"Maven Project Layout"},{"location":"layout/#project-layout","text":"You might be used to a discovery like project setup, where you just throw in you code files at random place into the project, then hopefully click a green triangle start button in your IDE and cross you fingers it will magically work. While this may work for tiny projects or little scripting codebases that you hammer out in a day, bigger software projects often have a long list of requirements and likewise are expected to compile and run reliable no matter to platform or developer cloning the project. This is where maven enters the game. Maven replaces the click based project configuration (where a developer sets up their project via IDE menus), by a central xml textual description, the `pom.xml . The good news is: Once the pom.xml is set up, no one ever needs to touch a UI menu again.","title":"Project Layout"},{"location":"layout/#files-and-folders","text":"The root of a maven project should roughly look like this: Before we go into the details, note that there are two important entires at root level: pom.xml which contains all project configuration. Almost everything presented on this webpage are snippets that extend this file. A src folder, all your source code, tests, even resources go somewhere into that folder. Depending on which configurations you add to your pom.xml , you might have additional content on top level. But for a start these are the minimum requirement for your project at root level. Next let's look at the nested content of the src folder. Everything that carries a red marker in the capture above must be in place exactly as shown . If you alter that structure, your project simply is not valid and there are zero guarantees for what happens when someone else attempts to build and run it. Your java sources go into src/main/java Your java tests fo into src/test/java Your resource files go into src/main/resources","title":"Files and Folders"},{"location":"layout/#groupid-artifactid-packages","text":"In the test/java and src/java folder you see subfolders: eu/kartoffelquadrat/printer . eu/kartoffelquadrat has a blue label. This on represents your groupId . The groupId is specific to the developer (or team of developers) responsible for the project. By convention it is the inverted domain name of your affiliation. So for instance if you are a student at McGill you could use: ca/mcgill instead of eu/kartoffelquadrat . It can also be longer than two segments, but it seems to have become an unwritten convention to use two segments. Do not use eu/kartoffelquadrat for your projects. That domain is owned by me, so you better not pretend to release software on my behalf. ;) liveprogramming is the artifactId . It has a yellow label. It describes the specific purpose of your project. For instance if you are developing a board game tic tac toe client, it could be ticTacToeClient . Optionally you can create further subfolders for sub-packages (purple label). E.g. if you have an MVC structure you can place parallel folders for model , view , control under your artifactId . Packages are optional for smaller projects, but for everything that has more than 5 classes, things can get very confusing without packages.","title":"GroupId, ArtifactId, Packages"},{"location":"minimalpom/","text":"Minimal Pom, Hello World Once you have decided on your groupId , artifactId and also set up the required folder structure, the next step is to create a minimal pom.xml file. You can use below template as starting point, although you will need to make some minor changes . Pom Template Create the pom.xml at top level of your project, then paste in the below template content: <?xml version=\"1.0\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> eu.kartoffelquadrat </groupId> <artifactId> projectname </artifactId> <packaging> jar </packaging> <version> 1.0 </version> <name> printer </name> <url> http://maven.apache.org </url> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <maven.compiler.target> 1.8 </maven.compiler.target> <maven.compiler.source> 1.8 </maven.compiler.source> <build.name> ProjectNameInCamelCase </build.name> </properties> <!-- main developer --> <developers> <developer> <name> Maximilian Schiedermeier </name> <email> maximilian.schiedermeier@mcgill.ca </email> <organization> kartoffelquadrat.eu </organization> <organizationUrl> https://github.com/kartoffelquadrat </organizationUrl> </developer> </developers> <!-- legal --> <licenses> <license> <name> MIT License </name> <url> http://www.opensource.org/licenses/mit-license.php </url> <distribution> repo </distribution> </license> </licenses> <dependencies> </dependencies> <build> <!-- Override default name of generated artifacts --> <finalName> ${build.name} </finalName> <plugins> </plugins> </build> </project> Changes Next go over below list and make sure to updated the indicated fields: Replace the groupId tag content by something that describes your group . Replace the artifactId tag content by something that describes your project purpose . Update the name tag to a single human readable word, describing your product. Update the build.name variable to a camelCase description of your product, as you want the generated executable file to be named. Update the developer name and info! Do not use my name! Choose a license, or remove the license block if you want to reserve all rights. Hello World Next create a file Launcher.java in the lowest level of your src/main/java/... folder with the following content: package eu.kartoffelquadrat.liveprogramming ; public class Launcher { public static void main ( String [] args ) { System . out . println ( \"Hello, World!\" ); } } Note : Make sure the package matches your groupid + artifactid + any other subpackages you have in your folder structure!","title":"Minimal Pom"},{"location":"minimalpom/#minimal-pom-hello-world","text":"Once you have decided on your groupId , artifactId and also set up the required folder structure, the next step is to create a minimal pom.xml file. You can use below template as starting point, although you will need to make some minor changes .","title":"Minimal Pom, Hello World"},{"location":"minimalpom/#pom-template","text":"Create the pom.xml at top level of your project, then paste in the below template content: <?xml version=\"1.0\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> eu.kartoffelquadrat </groupId> <artifactId> projectname </artifactId> <packaging> jar </packaging> <version> 1.0 </version> <name> printer </name> <url> http://maven.apache.org </url> <properties> <project.build.sourceEncoding> UTF-8 </project.build.sourceEncoding> <maven.compiler.target> 1.8 </maven.compiler.target> <maven.compiler.source> 1.8 </maven.compiler.source> <build.name> ProjectNameInCamelCase </build.name> </properties> <!-- main developer --> <developers> <developer> <name> Maximilian Schiedermeier </name> <email> maximilian.schiedermeier@mcgill.ca </email> <organization> kartoffelquadrat.eu </organization> <organizationUrl> https://github.com/kartoffelquadrat </organizationUrl> </developer> </developers> <!-- legal --> <licenses> <license> <name> MIT License </name> <url> http://www.opensource.org/licenses/mit-license.php </url> <distribution> repo </distribution> </license> </licenses> <dependencies> </dependencies> <build> <!-- Override default name of generated artifacts --> <finalName> ${build.name} </finalName> <plugins> </plugins> </build> </project>","title":"Pom Template"},{"location":"minimalpom/#changes","text":"Next go over below list and make sure to updated the indicated fields: Replace the groupId tag content by something that describes your group . Replace the artifactId tag content by something that describes your project purpose . Update the name tag to a single human readable word, describing your product. Update the build.name variable to a camelCase description of your product, as you want the generated executable file to be named. Update the developer name and info! Do not use my name! Choose a license, or remove the license block if you want to reserve all rights.","title":"Changes"},{"location":"minimalpom/#hello-world","text":"Next create a file Launcher.java in the lowest level of your src/main/java/... folder with the following content: package eu.kartoffelquadrat.liveprogramming ; public class Launcher { public static void main ( String [] args ) { System . out . println ( \"Hello, World!\" ); } } Note : Make sure the package matches your groupid + artifactid + any other subpackages you have in your folder structure!","title":"Hello World"},{"location":"profiles/","text":"","title":"Profiles"},{"location":"run/","text":"Run The whole point of Maven is that you can build your software reliably, no matter the environment - this also includes settings where you have no graphical access, and maybe not even an IDE. The default way to compile a maven project is therefore by command line. Run Plugins and Commands To run a program you need to have your pom.xml point to the desired launcher class. There can also be programs with multiple launcher classes, but this corner case we deal with later. On top, the startup procedure is often also dependent on the framework or library you are using. Especially GUI and reflective libraries tend to overload the default javaagent and therefore also bring their own plugins that need to be added to the pom.xml . Plugins Maven plugins, like dependencies are (once included in the pom.xml ) downloaded and added to the .m2 directory and classpath. However plugins are commonly compile-time dependencies, not run-time dependencies like libraries. Plugins merely target a modification of the default build and run process. In the default pom.xml you already see an empty section for plugins: <plugins> </plugins> All xml snippets shown in the following go directly within these tags. Run Plugin Samples Below you find sample run-plugins for Vanilla , Spring Boot and JavaFX projects. There are many more, but this selection should give you a good illustration of the procedure. Note how every plugin also slightly alters the launch command! (Command after xml snippet) Vanilla / No Frameworks Spring Boot Java FX <plugin> <groupId>org.codehaus.mojo</groupId> <artifactId>exec-maven-plugin</artifactId> <version>1.6.0</version> <executions> <execution> <goals> <goal>java</goal> </goals> </execution> </executions> <configuration> <mainClass>eu.kartoffelquadrat.printer.PrinterVsLogger</mainClass> </configuration> </plugin> Start your program with: mvn clean package exec:java ---No Plugins Needed: Launcher class is auto detected by annotation--- Start your program with: mvn clean package spring-boot:run <plugin> <groupId>org.openjfx</groupId> <artifactId>javafx-maven-plugin</artifactId> <version>0.0.8</version> <configuration> <mainClass>eu.kartoffelquadrat.javafxhelloworld.Launcher</mainClass> </configuration> </plugin> Start your program with: mvn clean package javafx:run","title":"Direct Run"},{"location":"run/#run","text":"The whole point of Maven is that you can build your software reliably, no matter the environment - this also includes settings where you have no graphical access, and maybe not even an IDE. The default way to compile a maven project is therefore by command line.","title":"Run"},{"location":"run/#run-plugins-and-commands","text":"To run a program you need to have your pom.xml point to the desired launcher class. There can also be programs with multiple launcher classes, but this corner case we deal with later. On top, the startup procedure is often also dependent on the framework or library you are using. Especially GUI and reflective libraries tend to overload the default javaagent and therefore also bring their own plugins that need to be added to the pom.xml .","title":"Run Plugins and Commands"},{"location":"run/#plugins","text":"Maven plugins, like dependencies are (once included in the pom.xml ) downloaded and added to the .m2 directory and classpath. However plugins are commonly compile-time dependencies, not run-time dependencies like libraries. Plugins merely target a modification of the default build and run process. In the default pom.xml you already see an empty section for plugins: <plugins> </plugins> All xml snippets shown in the following go directly within these tags.","title":"Plugins"},{"location":"run/#run-plugin-samples","text":"Below you find sample run-plugins for Vanilla , Spring Boot and JavaFX projects. There are many more, but this selection should give you a good illustration of the procedure. Note how every plugin also slightly alters the launch command! (Command after xml snippet) Vanilla / No Frameworks Spring Boot Java FX <plugin> <groupId>org.codehaus.mojo</groupId> <artifactId>exec-maven-plugin</artifactId> <version>1.6.0</version> <executions> <execution> <goals> <goal>java</goal> </goals> </execution> </executions> <configuration> <mainClass>eu.kartoffelquadrat.printer.PrinterVsLogger</mainClass> </configuration> </plugin> Start your program with: mvn clean package exec:java ---No Plugins Needed: Launcher class is auto detected by annotation--- Start your program with: mvn clean package spring-boot:run <plugin> <groupId>org.openjfx</groupId> <artifactId>javafx-maven-plugin</artifactId> <version>0.0.8</version> <configuration> <mainClass>eu.kartoffelquadrat.javafxhelloworld.Launcher</mainClass> </configuration> </plugin> Start your program with: mvn clean package javafx:run","title":"Run Plugin Samples"},{"location":"signature/","text":"","title":"Signature"}]}